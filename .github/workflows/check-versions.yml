name: Check Package Versions
permissions:
  contents: write
  pull-requests: write

on:
  workflow_dispatch:
  schedule:
    # Run daily at 6 AM UTC
    - cron: "0 6 * * *"
  push:
    branches:
      - main
    paths:
      - repackaging/images.yaml
      - check-*-version.*

jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Generate matrix from images.yaml
        id: set-matrix
        run: |
          matrix=$(yq eval -o=json '.images[] | select(.type != null) | select(.version != "latest") |= pick(["name", "type", "package", "version"])' repackaging/images.yaml | jq -cs .)
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  check-versions:
    needs: generate-matrix
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        if: ${{ matrix.type == 'node' }}
        uses: actions/setup-node@v5
        with:
          node-version: "22"

      - name: Setup Python
        if: ${{ matrix.type == 'python' }}
        uses: actions/setup-python@v6
        with:
          python-version: "3.13"

      - name: Setup crane
        uses: imjasonh/setup-crane@v0.4

      - name: Check npm package version
        id: check-npm
        if: ${{ matrix.type == 'node' }}
        run: |
          result=$(node scripts/check-npm-version.js "${{ matrix.package }}" "${{ matrix.version }}")
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$result" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Store exit code
          if node scripts/check-npm-version.js "${{ matrix.package }}" "${{ matrix.version }}" > /dev/null 2>&1; then
            echo "has_update=true" >> $GITHUB_OUTPUT
          else
            echo "has_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Check PyPI package version
        id: check-pypi
        if: ${{ matrix.type == 'python' }}
        run: |
          result=$(python scripts/check-pypi-version.py "${{ matrix.package }}" "${{ matrix.version }}")
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$result" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Store exit code
          if python scripts/check-pypi-version.py "${{ matrix.package }}" "${{ matrix.version }}" > /dev/null 2>&1; then
            echo "has_update=true" >> $GITHUB_OUTPUT
          else
            echo "has_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Check Docker image version
        id: check-docker
        if: ${{ matrix.type == 'docker' }}
        run: |
          result=$(python scripts/check-docker-version.py "${{ matrix.package }}:${{ matrix.version }}")
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$result" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Store exit code
          if python scripts/check-docker-version.py "${{ matrix.package }}:${{ matrix.version }}" > /dev/null 2>&1; then
            echo "has_update=true" >> $GITHUB_OUTPUT
          else
            echo "has_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract latest version
        id: extract-version
        if: ${{ (matrix.type == 'node' && steps.check-npm.outputs.has_update == 'true') || (matrix.type == 'python' && steps.check-pypi.outputs.has_update == 'true') || (matrix.type == 'docker' && steps.check-docker.outputs.has_update == 'true') }}
        run: |
          if [ "${{ matrix.type }}" = "node" ]; then
            latest_version=$(echo '${{ steps.check-npm.outputs.result }}' | jq -r '.latestVersion')
          elif [ "${{ matrix.type }}" = "python" ]; then
            latest_version=$(echo '${{ steps.check-pypi.outputs.result }}' | jq -r '.latestVersion')
          elif [ "${{ matrix.type }}" = "docker" ]; then
            latest_version=$(echo '${{ steps.check-docker.outputs.result }}' | jq -r '.latestTag')
          fi
          echo "latest_version=$latest_version" >> $GITHUB_OUTPUT

      - name: Update images.yaml and create PR
        if: ${{ (matrix.type == 'node' && steps.check-npm.outputs.has_update == 'true') || (matrix.type == 'python' && steps.check-pypi.outputs.has_update == 'true') || (matrix.type == 'docker' && steps.check-docker.outputs.has_update == 'true') }}
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const packageName = '${{ matrix.name }}';
            const currentVersion = '${{ matrix.version }}';
            const latestVersion = '${{ steps.extract-version.outputs.latest_version }}';
            const packageType = '${{ matrix.type }}';
            const packageId = '${{ matrix.package }}';

            // Read the current images.yaml
            const imagesPath = 'repackaging/images.yaml';
            let imagesContent = fs.readFileSync(imagesPath, 'utf8');

            // Create a regex pattern to find and replace the specific package version
            // This looks for the package entry and updates the version line
            const packageRegex = new RegExp(
              `(- name: ${packageName}\\s*\\n(?:.*\\n)*?\\s*version: )${currentVersion.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`,
              'g'
            );

            const updatedContent = imagesContent.replace(packageRegex, `$1${latestVersion}`);

            if (updatedContent === imagesContent) {
              console.error(`Failed to update ${packageName} from ${currentVersion} to ${latestVersion}`);
              console.error('Pattern did not match. Current content around package:');
              const lines = imagesContent.split('\n');
              const nameIndex = lines.findIndex(line => line.includes(`name: ${packageName}`));
              if (nameIndex >= 0) {
                console.error(lines.slice(Math.max(0, nameIndex - 2), nameIndex + 8).join('\n'));
              }
              return;
            }

            // Create branch name
            const branchName = `update-${packageName}-${latestVersion}`;

            try {
              // Check if branch already exists
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branchName
                });
                console.log(`Branch ${branchName} already exists, skipping PR creation`);
                return;
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                // Branch doesn't exist, continue with creation
              }

              // Get the latest commit SHA from main
              const mainBranch = await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: 'main'
              });

              // Create new branch
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: mainBranch.data.commit.sha
              });

              // Get current file content to get the SHA
              const currentFile = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: imagesPath,
                ref: branchName
              });

              // Update the file
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: imagesPath,
                message: `Update ${packageName} from ${currentVersion} to ${latestVersion}`,
                content: Buffer.from(updatedContent).toString('base64'),
                sha: currentFile.data.sha,
                branch: branchName
              });

              // Get version check results for PR body
              let result;
              if (packageType === 'node') {
                result = JSON.parse(`${{ steps.check-npm.outputs.result }}`);
              } else if (packageType === 'python') {
                result = JSON.parse(`${{ steps.check-pypi.outputs.result }}`);
              } else if (packageType === 'docker') {
                result = JSON.parse(`${{ steps.check-docker.outputs.result }}`);
              }

              // Create pull request
              const pr = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Update ${packageName} from ${currentVersion} to ${latestVersion}`,
                head: branchName,
                base: 'main',
                body: `## Package Update
            **Package:** \`${packageId}\`
            **Type:** ${packageType}
            **Current Version:** \`${currentVersion}\`
            **Latest Version:** \`${latestVersion}\`

            ### Version Check Details
            \`\`\`json
            ${JSON.stringify(result, null, 2)}
            \`\`\`

            ### Changes
            - Updated \`${packageName}\` version in \`repackaging/images.yaml\`

            ### Testing
            Please verify that the updated package works correctly before merging.

            ---
            *This pull request was automatically created by the version check workflow.*`
              });

              // Add labels
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: ['version-update', `package:${packageName}`, `type:${packageType}`, 'automated']
              });

              console.log(`Created pull request #${pr.data.number} for ${packageName} update`);

            } catch (error) {
              console.error(`Error creating pull request for ${packageName}:`, error);
              throw error;
            }
